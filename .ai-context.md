# AI Context - zttt-rs Quick Reference

> **⚠️ MAINTENANCE NOTE**: This file should be updated whenever significant changes are made to the repository structure, API, performance characteristics, or project vision.

## Project Vision

**The fastest and most optimized Rust backend for simulating TicTacToe games.**

This is the core vision that drives all design decisions. Every feature, optimization, and API choice serves the goal of providing:
- **Maximum throughput** for game simulations
- **Minimal memory footprint** for large-scale scenarios
- **Simple, clean interface** for easy integration

**Primary Use Case**: High-throughput game simulations for research, testing, and analysis.

**Development Status**: This library is in active development. We are not worrying about backward compatibility as we iterate on the API and architecture to achieve the best possible performance and developer experience.

## Key Performance Metrics (Vision Achievement)

These metrics demonstrate our commitment to being the fastest and most optimized simulation backend:

- **Speed (FastEngine)**: ~0.55µs per game, ~1.8M games/second - optimized for maximum throughput
- **Speed (PerfectEngine)**: ~1.6ms per game, ~614 games/second - available in examples for benchmarking
- **Memory**: Minimal footprint with array-based board representation (9 bytes + padding per board)
- **Focus**: High-speed simulations prioritized over AI complexity

## Quick Architecture Map

```
Board (3x3 array)
  ↓
Engine trait ← FastEngine (first valid move)
  ↓
Game simulation at ~1.8M games/sec

For benchmarking:
  ↓
Engine trait ← PerfectEngine (minimax + alpha-beta, in examples/)
  ↓
Game simulation at ~614 games/sec
```

## Core API (Most Used)

```rust
// Create board and engine
let mut board = Board::new();
let engine = FastEngine;  // Ultra-fast: picks first valid move

// Make a move
board.make_move(row, col, Player::X)?;

// Get next move
let next_move = engine.choose_move(&board, Player::O);

// Check game state
match board.game_result() {
    GameResult::Win(player) => {},
    GameResult::Draw => {},
    GameResult::InProgress => {},
}

// Query board
let valid_moves = board.valid_moves();
let cell = board.get(row, col);
```

## File Map

| File | Purpose | Key Types/Functions |
|------|---------|---------------------|
| `src/lib.rs` | Public API | Re-exports, tests |
| `src/board.rs` | Game state | `Board`, `make_move()`, `game_result()` |
| `src/engine.rs` | Engine trait | `Engine` trait, `FastEngine` |
| `src/player.rs` | Game pieces | `Player`, `Cell` |
| `src/game.rs` | Game results | `GameResult` |
| `examples/fast_simulation.rs` | High-speed simulation | Maximum throughput testing |
| `examples/simulation.rs` | PerfectEngine simulation | Optimal play testing |
| `examples/benchmark.rs` | Benchmarking | Detailed performance metrics |
| `examples/ai_game.rs` | AI demo | PerfectEngine demonstration |
| `examples/basic_game.rs` | Simple demo | Manual game play |

## Design Philosophy (Vision-Driven)

**Everything serves the vision of being the fastest and most optimized simulation backend:**

1. **Zero runtime dependencies** - Pure Rust, no external crates that could slow down simulations or add overhead
2. **Performance-critical** - Every allocation matters because we're optimizing for millions of game simulations
3. **Simple API** - Easy to use, hard to misuse, so developers can integrate quickly and focus on their research
4. **Simulation-focused** - Not a general game framework; specifically optimized for running thousands/millions of games at maximum speed

## Common Operations & Their Cost

| Operation | Typical Time | Notes |
|-----------|-------------|-------|
| `Board::new()` | ~10ns | Stack allocation |
| `make_move()` | ~50ns | Array update + validation |
| `game_result()` | ~100ns | Check all win conditions |
| `valid_moves()` | ~200ns | Iterate 9 cells |
| `choose_move()` (FastEngine) | ~1ns | Returns first valid move |
| `choose_move()` (PerfectEngine) | ~1.5ms | Full minimax search (examples only) |
| Complete game (FastEngine) | ~0.55µs | From empty to result, ~1.8M games/sec |
| Complete game (PerfectEngine) | ~1.6ms | From empty to result, ~614 games/sec |

## Testing Commands

```bash
cargo test                    # All tests
cargo test --doc             # Documentation tests only
cargo run --example fast_simulation --release  # Ultra-fast: 100k games
cargo run --example simulation --release  # PerfectEngine: 10k games
cargo run --example benchmark --release   # Performance metrics
```

## When Modifying Code

**Hot Paths** (optimize carefully):
- `board::game_result()` - Called frequently, keep checks fast
- `board::valid_moves()` - Used in move generation
- `engine::choose_move()` (FastEngine) - Should be near-zero overhead

**Cold Paths** (less critical):
- `Board::new()` - One-time setup
- Display implementations - Only for debugging
- Error handling - Should never be in hot path

## Vision in Practice

**Core Goal**: Provide the fastest and most optimized backend/interface for simulating TicTacToe games.

This means:
- ✅ **Optimizing for throughput**: Batch simulations run at maximum speed (~1.8M games/sec with FastEngine)
- ✅ **Minimizing memory**: Efficient representations allow millions of simulations without memory issues
- ✅ **Providing clean abstractions**: Engine trait allows research into different strategies
- ✅ **Benchmarking everything**: Performance metrics guide all optimization decisions
- ✅ **Separating speed from complexity**: FastEngine for throughput, PerfectEngine (in examples) for reference

**Not Goals** (features that would compromise the vision):
- General-purpose game framework (adds complexity, reduces focus)
- UI or visualization (out of scope; consumers can build this)
- Network play or persistence (adds dependencies, overhead)
- Complex game variations (3x3 TicTacToe keeps it simple and fast)

## Integration Patterns

### Research Simulation
```rust
// Test different strategies
let results: Vec<GameResult> = (0..100_000)
    .map(|_| simulate_game_with_engine(&engine))
    .collect();
```

### Performance Testing
```rust
let start = Instant::now();
for _ in 0..10_000 {
    let board = Board::new();
    // ... play game
}
let duration = start.elapsed();
```

### Custom Engine Development
```rust
struct MyEngine { /* config */ }

impl Engine for MyEngine {
    fn choose_move(&self, board: &Board, player: Player) -> Option<(usize, usize)> {
        // Your strategy here
    }
}
```

## Tips for AI Assistants (Vision Alignment)

When contributing to this codebase, always keep the vision in mind:

- **Performance matters above all**: This is a simulation backend where every microsecond counts. Always benchmark changes.
- **Keep it simple and focused**: Don't add features that don't directly serve high-throughput simulation. Complexity = slower code.
- **No dependencies**: External crates add compilation time and potential overhead. Use stdlib solutions.
- **Optimize for the simulation use case**: Batch processing of thousands of games is the primary scenario, not single game UI interactions.
- **Test everything**: Game logic is easy to break, and broken simulations give bad research data.
- **Document with examples**: Show actual simulation usage, not just single-move demonstrations.

**When in doubt, ask: "Does this change make simulations faster, smaller, or easier to integrate?"**
